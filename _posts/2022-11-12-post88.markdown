---
title: "JVM 메모리 영역"
date: 2022-11-12
last_modified_at: 2022-11-12
toc: true
toc_sticky: true
categories: 
  - Java
tags:
  - [JVM]
---

> 프로그램이 실행되면 JVM은 OS로부터 메모리를 할당받고, 그 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.  

![image](https://user-images.githubusercontent.com/99777315/201473743-d944cfda-d2f1-479f-a8d3-d7ada65be2f4.png)  

## Runtime Data Area
### 1. Class Area(=Method Area)
- Method Area, Class Area, Code Area, Static Area
- 클래스정보(멤버변수의 이름), 변수정보(데이터타입, 접근제어자정보), 메소드정보(메소드 이름, 리턴타입, 파라미터, 접근제어자 정보), static변수, final class변수, Constant pool(상수풀 : 문자상수, 타입, 필드, 객체참조가 저장됨)등을 분류해서 저장한다.
- JVM이 동작해서 클래스가 로딩될 때 생성

### 2. Heap Area
- new 키워드로 생성된 객체와 배열이 저장되는 영역
- Method Area에 로드된 클래스만 생성이 가능하다.
- GC의 주요 대상이 된다.(Stack, Class Area도 대상이 된다.)
- 효율적인 GC를 위해 메모리 영역이 분리되어 있다.(Eden, Survivor1,2, Old)
- 런타임시 할당된다.

### 3. Stack Area
- 지역변수, 파라미터, 리턴값, 연산에 사용되는 임시값등이 생성되는 영역
- 메소드를 호출할 때마다 개별적으로 스택이 생성되며 종료 시 영역에서 해제된다.
- 컴파일 타임 시 할당된다.

>런타임과 컴파일타임
- 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정  
  (Systenx Error, 파일참조오류, 타입체크오류 등)
- 런타임 : 컴파일타임 이후 프로그램이 실행되는 때  
  (0나누기 오류, Null참조오류, 메모리부족오류)

### 4. PC Register
- 스레드가 생성될때마다 생성되며 현재 스레드가 실행되는 부분의 주소와 명령을 저장하는 영역
- 이를 이용해서 스레드를 돌아가면서 수행할 수 있게 한다. 

### 5. Native Method Stack
- 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역(JNI)

> 멀티스레드 시 공유되는 메모리 영역은?  
메소드영역과 힙영역은 모든 스레드가 공유한다.  
스택영역,PC레지스터,네이티브 메소드 스택은 각각의 스레드마다 생성되고 공유되지 않는다.  

## 캐시메모리와 메인메모리
> 1. CPU에서 어떤 작업을 처리하고자 한다.  
2. 가상주소에 있는 데이터를 메모리에 요청한다.  
3. MMU(Memory Management Unit)이 가상주소를 물리주소로 번역한다.  
4. 물리주소를 캐시(or메인)메모리에 전달한다.  
5. CPU에 전달된 명령을 처리한다.  

### 1. 캐시메모리 사용
CPU → 가상 주소 전달 → MMU → 물리 주소 전달 → Cache → 주소에 해당하는 명령어 전달 → CPU

### 2. 메인메모리 사용
CPU → 가상 주소 전달 → MMU → 물리 주소 전달 → Cache → 데이터 x → 메인 메모리 → 해당 명령어 블록 인출 → 명령어 블록 Cache에 저장 → 명령어 전달 → CPU

### 캐시메모리가 작업 처리면에서 더 빠르다.
> LruCache
- 제한된 사이즈에서 최근에 가장 적게 참조된(Least Recently Used) 가장 오래된 객체를 제거하는 데이터 구조
- 대표적으로 Bitmap 캐싱에 사용됨