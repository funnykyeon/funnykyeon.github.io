---
title: "기술면접 질문 정리 운영체제"
date: 2022-11-08
last_modified_at: 2022-11-08
toc: true
toc_sticky: true
categories: 
  - CS
tags:
  - [면접질문]
---

## 프로세스와 쓰레드의 차이에 대해 설명하시오.
프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않는다.  
프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.

 

쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있다.  
쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행된다.


## 멀티 프로세스와 멀티 쓰레드의 특징에 대해 설명하시오.
멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만  
멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있다.  

멀티 쓰레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만  
하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있다.

## 멀티 쓰레드의 동시성과 병렬성을 설명하시오.
동시성은 멀티 작업을 위해 싱글 코어에서 여러 개의 쓰레드가 번갈아 실행하는 것을 말한다.  
(동시에 실행하는 것처럼 보이지만 사실은 번갈아가며 실행하고 있는 것임)  

병렬성은 멀티 작업을 위해 멀티 코어에서 한 개 이상의 쓰레드를 포함하는 각 코어들을 동시에 실행하는 것을 말한다.  

## 멀티 쓰레드 환경에서의 주의사항을 설명하시오.
다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착 상태가 발생하지 않도록 주의해야 한다.  

## 데드락에 대해 설명하시오.
둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말한다.  

예를 들어, 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면  
두 프로세스는 서로 자원을 얻기 위해 무한정 기다리게 된다.


- 데드락의 4가지 조건  
  - 비선점 (Nonpreemptive) : 다른 프로세스의 자원을 뺏을 수 없음.
  - 순환 대기 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조.
  - 점유 대기 (Hold & Wait) : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.
  - 상호 배제(Mutual Exclusion) : 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우.

## 콘보이 현상(convoy effect)이란 무엇이고, 콘보이 현상이 발생될 수 있는 CPU 스케줄러 알고리즘은 무엇인지 설명하시오.
콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상을 말한다.  

FCFS(First-Come First Served) 스케줄링은 비선점형으로, 순차적으로 먼저 큐에 들어온 작업부터 실행하므로 콘보이 현상이 발생할 수 있다.  

## 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명하시오.
선점형은 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음을 말하고,  
비선점형은 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음을 말한다.  

## 동기와 비동기의 차이에 대해 설명하시오.
![image](https://user-images.githubusercontent.com/99777315/200592529-0e79d28f-42b1-42bf-ae38-4e36744026a8.png)  

동기는 순차적, 직렬적으로 테스크를 수행하고, 비동기는 병렬적으로 테스크를 수행한다.  
예를 들어, 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때,  
동기는 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 테스크들은 블로킹(Blocking, 작업 중단)된다.  

비동기는 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 테스크를 계속해 수행한다.

## Critical Section(임계영역)에 대해 설명하시오.
임계 영역이란 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말한다.

임계 영역 문제를 해결하기 위해서는 아래의 3가지 조건을 충족해야 한다.  
- 상호 배제(Mutual exclution) - 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.
- 진행(Progress) - 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 어느 것이 들어갈지 결정 해주어야 한다.
- 한정 대기(Bounded waiting) - 다른 프로세스의 기아를 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 한다.

## 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명하시오.
뮤텍스는 Lock을 사용해 하나의 프로세스나 쓰레드를 단독으로 실행하게 한다.  
반면에 세마포어는 공유자원에 세마포어 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있다.  
세마포어의 변수 → 공유자원의 개수를 나타내는 변수  

현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다.  
하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 한다.  

0과 1의 값만 갖는 세마포어 → 이진 세마포어(binary semaphore) (= 뮤텍스)  
도메인 제한이 없는 세마포어(0,1 뿐만아니라 2,3,4 등의 값들 또한 가질 수 있는) → 카운팅 세마포어(counting semaphore)  

## 페이지 교체 알고리즘에 대해 설명하시오.
- 페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(페이징 부재시) 어떤 페이지 프레임을 선택해 교체할 것인지 결정하는 방법을 페이지 교체 알고리즘이라고 한다.  
- FIFO(first in first out)
  - 가장 간단한 알고리즘으로, 메모리에 올라온 지 가장 오래된 페이지를 교체한다. 간단하고, 초기화 코드에 대해 적절한 방법이며, 페이지가 올라온 순서를 큐에 저장한다.
- 최적(Optimal) 페이지 교체
  - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘이다. 최적 페이지 교체는 선행 조건이 있는데, 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다는 것이다. 이 조건은 실제 활용에선 알 방법이 없기 때문에 최적 알고리즘은 구현이 불가능한 알고리즘이다. 때문에 연구를 목적으로 주로 사용된다.
- LRU(least-recently-used)
  - 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘이다. OPT 알고리즘의 방식과 비슷한 효과를 낼 수 있는 방법이며, OPT 알고리즘보다 페이지 교체 횟수가 높지만 FIFO 알고리즘 보다 효율적이다.
- LFU(least-frequently-used)
  - 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘이다. 만약 대상인 페이지가 여러 개 일 경우, LRU 알고리즘을 따라 가장 오래 사용되지 않은 페이지로 교체한다.
- MFU(most-frequently-used)
  - LFU 알고리즘과 반대로, 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다.
- LFU와 MFU는 실제 사용에 잘 쓰이지 않는다.
  - 구현에 상당한 비용이 들고,
  - 최적 페이지 교체 정책을 (LRU 만큼) 제대로 유사하게 구현해내지 못하기 때문이다.

## 컨텍스트 스위칭(Context Switching)이 무엇인지 설명하시오.
멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업을 말한다.

###### ※ 컨텍스트? CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들.